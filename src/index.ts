import { BaseAPIClient } from './base.js';
import {
  CrawlRequest,
  CrawlResult,
  SpiderOptions,
  PageOptions,
  PluginOptions,
  CrawlEvent,
  CreateCrawlRequest,
  SearchRequest,
  SearchOptions,
  SearchEvent,
  SearchResult,
  CreateSearchRequest,
  SitemapNode,
  SearchStatus,
  CreateBatchCrawlRequest,
  BatchSpiderOptions,
  SitemapRequest,
  SitemapOptions,
  SitemapStatus,
  SitemapEvent,
  SitemapOutputFormat,
} from './types.js';
import axios from 'axios';

export * from './types.js';

export class WaterCrawlAPIClient extends BaseAPIClient {
  async getCrawlRequestsList(
    page?: number,
    pageSize?: number,
  ): Promise<{ results: CrawlRequest[] }> {
    return this.get('/api/v1/core/crawl-requests/', { page, page_size: pageSize });
  }

  async getCrawlRequest(itemId: string): Promise<CrawlRequest> {
    return this.get(`/api/v1/core/crawl-requests/${itemId}/`);
  }

  async createCrawlRequest(
    url: string,
    spiderOptions: SpiderOptions = {},
    pageOptions: PageOptions = {},
    pluginOptions: PluginOptions = {},
  ): Promise<CrawlRequest> {
    const request: CreateCrawlRequest = {
      url,
      options: {
        spider_options: spiderOptions,
        page_options: pageOptions,
        plugin_options: pluginOptions,
      },
    };
    return this.post('/api/v1/core/crawl-requests/', request);
  }

  async createBatchCrawlRequest(
    urls: string[],
    spiderOptions: BatchSpiderOptions = {},
    pageOptions: PageOptions = {},
    pluginOptions: PluginOptions = {},
  ): Promise<CrawlRequest> {
    const request: CreateBatchCrawlRequest = {
      urls,
      options: {
        spider_options: spiderOptions,
        page_options: pageOptions,
        plugin_options: pluginOptions,
      },
    };
    return this.post('/api/v1/core/crawl-requests/batch/', request);
  }

  async stopCrawlRequest(itemId: string): Promise<null> {
    return this.delete(`/api/v1/core/crawl-requests/${itemId}/`);
  }

  async downloadCrawlRequest(itemId: string): Promise<CrawlResult[]> {
    return this.get(`/api/v1/core/crawl-requests/${itemId}/download/`);
  }

  async *monitorCrawlRequest(
    itemId: string,
    download: boolean = true,
  ): AsyncGenerator<CrawlEvent, void, unknown> {
    yield* this.fetchStream<CrawlEvent>(`/api/v1/core/crawl-requests/${itemId}/status/`, {
      params: { prefetched: download },
    });
  }

  async getCrawlRequestResults(itemId: string, page?: number, pageSize?: number, download?: boolean): Promise<{ results: CrawlResult[] }> {
    return this.get(`/api/v1/core/crawl-requests/${itemId}/results/`, {
      page,
      page_size: pageSize,
      prefetched: download
    });
  }

  /**
   * Download the content of a crawl result
   * @deprecated This method will be removed in a future version. Please use alternative methods for downloading result data.
   */
  async downloadResult(resultObject: CrawlResult): Promise<Record<string, any>> {
    const response = await axios.get(resultObject.result);
    return response.data;
  }

  async scrapeUrl(
    url: string,
    pageOptions: PageOptions = {},
    pluginOptions: PluginOptions = {},
    sync: boolean = true,
    download: boolean = true,
  ): Promise<Record<string, any> | CrawlRequest> {
    const request = await this.createCrawlRequest(url, {}, pageOptions, pluginOptions);

    if (!sync) {
      return request;
    }

    for await (const event of this.monitorCrawlRequest(request.uuid, download)) {
      if (event.type === 'result') {
        return event.data as CrawlResult;
      }
    }

    throw new Error('No result received from crawl');
  }

  // Sitemap methods
  /**
   * Get a crawl request for sitemap operations
   * @param crawlRequest Crawl request object or UUID
   * @returns Promise with the crawl request
   * @throws Error if the sitemap is not available
   */
  private async getCrawlRequestForSitemap(
    crawlRequest: string | CrawlRequest,
  ): Promise<CrawlRequest> {
    const request =
      typeof crawlRequest === 'string' ? await this.getCrawlRequest(crawlRequest) : crawlRequest;

    if (!request.sitemap) {
      throw new Error('Sitemap not found in crawl request');
    }

    return request;
  }

  /**
   * Downloads a sitemap generated by a crawl request
   * @param crawlRequest Crawl request object or UUID
   * @param outputFormat Output format of the sitemap. Defaults to {@link SitemapOutputFormat.Json}
   * @returns The sitemap in the specified format
   * @throws Error if the sitemap is not available
   */
  async getCrawlRequestSitemap(
    crawlRequest: string | CrawlRequest,
    outputFormat: SitemapOutputFormat = SitemapOutputFormat.Json,
  ): Promise<SitemapNode[] | string | object> {
    const request = await this.getCrawlRequestForSitemap(crawlRequest);
    if (!request.sitemap) {
      throw new Error('Sitemap URL is missing or undefined');
    }
    if (outputFormat === SitemapOutputFormat.Json) {
      const response = await axios.get<SitemapNode[]>(request.sitemap);
      return response.data;
    } else if (outputFormat === SitemapOutputFormat.Markdown) {
      return this.get<string>(`/api/v1/core/crawl-requests/${request.uuid}/sitemap/markdown/`);
    } else if (outputFormat === SitemapOutputFormat.Graph) {
      return this.get<object>(`/api/v1/core/crawl-requests/${request.uuid}/sitemap/graph/`);
    }

    throw new Error('Unsupported sitemap output format');
  }

  /**
   * Download the sitemap for a crawl request
   * @param crawlRequest Crawl request object or UUID
   * @returns Promise with the sitemap data
   * @deprecated
   */
  async downloadSitemap(crawlRequest: string | CrawlRequest): Promise<SitemapNode[]> {
    process.emitWarning(
      'The downloadSitemap method is deprecated and will be removed in a future version. Please use the getCrawlRequestSitemap method instead.',
      {
        code: 'DEP0001',
        type: 'DeprecationWarning',
      },
    );
    return (await this.getCrawlRequestSitemap(crawlRequest, SitemapOutputFormat.Json)) as Promise<
      SitemapNode[]
    >;
  }

  /**
   * Download the sitemap as a graph representation for visualization
   * @param crawlRequest Crawl request object or UUID
   * @returns Promise with the sitemap graph data
   * @deprecated
   */
  async downloadSitemapGraph(crawlRequest: string | CrawlRequest): Promise<object> {
    process.emitWarning(
      'The downloadSitemapGraph method is deprecated and will be removed in a future version. Please use the getCrawlRequestSitemap method instead.',
      {
        code: 'DEP0001',
        type: 'DeprecationWarning',
      },
    );
    return (await this.getCrawlRequestSitemap(
      crawlRequest,
      SitemapOutputFormat.Graph,
    )) as Promise<object>;
  }

  /**
   * Download the sitemap as a markdown document
   * @param crawlRequest Crawl request object or UUID
   * @returns Promise with the sitemap markdown content
   * @deprecated
   */
  async downloadSitemapMarkdown(crawlRequest: string | CrawlRequest): Promise<string> {
    process.emitWarning(
      'The downloadSitemapMarkdown method is deprecated and will be removed in a future version. Please use the getCrawlRequestSitemap method instead.',
      {
        code: 'DEP0001',
        type: 'DeprecationWarning',
      },
    );
    return (await this.getCrawlRequestSitemap(
      crawlRequest,
      SitemapOutputFormat.Markdown,
    )) as Promise<string>;
  }

  // Search methods
  /**
   * Get a paginated list of search requests
   * @param page Page number (1-indexed, default: 1)
   * @param pageSize Number of items per page (default: 10)
   * @returns Promise with paginated search requests
   */
  async getSearchRequestsList(
    page?: number,
    pageSize?: number,
  ): Promise<{ results: SearchRequest[] }> {
    return this.get('/api/v1/core/search/', { page: page || 1, page_size: pageSize || 10 });
  }

  /**
   * Get details of a specific search request
   * @param itemId UUID of the search request
   * @param download If true, download results; if false, return URLs
   * @returns Promise with search request details
   */
  async getSearchRequest(itemId: string, download: boolean = false): Promise<SearchRequest> {
    return this.get(`/api/v1/core/search/${itemId}/`, { prefetched: download });
  }

  /**
   * Create a new search request
   * @param query Search query string
   * @param searchOptions Search options
   * @param resultLimit Maximum number of results to return
   * @param sync If true, wait for results; if false, return immediately
   * @param download If true, download results; if false, return URLs
   * @returns If sync=true: Complete search results; If sync=false: Search request object
   */
  async createSearchRequest(
    query: string,
    searchOptions: SearchOptions = {},
    resultLimit: number = 5,
    sync: boolean = true,
    download: boolean = true,
  ): Promise<SearchRequest | SearchResult[]> {
    const request: CreateSearchRequest = {
      query,
      search_options: searchOptions,
      result_limit: resultLimit,
    };

    const response = await this.post<SearchRequest>('/api/v1/core/search/', request);

    if (!sync) {
      return response;
    }

    // Monitor the search request until completion
    for await (const event of this.monitorSearchRequest(response.uuid, download)) {
      if (event.type === 'state') {
        const data = event.data as SearchRequest;
        if (
          [SearchStatus.Finished, SearchStatus.Failed, SearchStatus.Canceled].includes(data.status)
        ) {
          return data.result as SearchResult[];
        }
      }
    }

    throw new Error('Search request failed or timed out');
  }

  /**
   * Monitor a search request in real-time
   * @param itemId UUID of the search request to monitor
   * @param download If true, download results; if false, return URLs
   * @returns AsyncGenerator yielding search events
   */
  async *monitorSearchRequest(
    itemId: string,
    download: boolean = true,
  ): AsyncGenerator<SearchEvent, void, unknown> {
    yield* this.fetchStream<SearchEvent>(`/api/v1/core/search/${itemId}/status/`, {
      params: { prefetched: download },
    });
  }

  /**
   * Stop a running search request
   * @param itemId UUID of the search request to stop
   * @returns Promise that resolves when the request is stopped
   */
  async stopSearchRequest(itemId: string): Promise<null> {
    return this.delete(`/api/v1/core/search/${itemId}/`);
  }

  /**
   * Create a new sitemap request
   * @param url URL of the sitemap
   * @param sitemapOptions Options for the sitemap
   * @param sync If true, wait for the request to complete
   * @param download If true, download the sitemap
   * @returns Promise that resolves to the created sitemap request
   */
  async createSitemapRequest(
    url: string,
    sitemapOptions: SitemapOptions = {
      include_subdomains: true,
      ignore_sitemap_xml: false,
      search: null,
      include_paths: [],
      exclude_paths: [],
    },
    sync: boolean = false,
    download: boolean = true,
  ): Promise<SitemapRequest | Array<string> | string> {
    const request = {
      url,
      options: sitemapOptions,
    } as SitemapRequest;
    const response = await this.post<SitemapRequest>('/api/v1/core/sitemaps/', request);

    if (!sync) {
      return response;
    }

    // Monitor the search request until completion
    for await (const event of this.monitorSitemapRequest(response.uuid, download)) {
      if (event.type === 'state') {
        const data = event.data as SitemapRequest;
        if (
          [SitemapStatus.Finished, SitemapStatus.Failed, SitemapStatus.Canceled].includes(
            data.status as SitemapStatus,
          )
        ) {
          return data.result as Array<string> | string;
        }
      }
    }

    throw new Error('Sitemap request failed or timed out');
  }

  /**
   * Get a sitemap request by ID
   * @param id UUID of the sitemap request
   * @param download If true, download the sitemap; if false, return the sitemap URL
   * @returns Promise that resolves to the sitemap request
   */
  async getSitemapRequest(id: string, download: boolean = false): Promise<SitemapRequest> {
    return this.get<SitemapRequest>(`/api/v1/core/sitemaps/${id}/`, {
      params: {
        prefetched: download,
      },
    });
  }

  /**
   * List all sitemap requests with pagination
   * @param page Page number
   * @param pageSize Status of the sitemap request
   * @returns Promise that resolves to the paginated list of sitemap requests
   */
  async listSitemapRequests(
    page: number = 1,
    pageSize: number = 10,
  ): Promise<{ results: SitemapRequest[] }> {
    return this.get<{ results: SitemapRequest[] }>(`/api/v1/core/sitemaps/`, {
      params: {
        page,
        page_size: pageSize,
      },
    });
  }

  /**
   * Subscribe to sitemap request status updates using Server-Sent Events (SSE)
   * @param uuid UUID of the sitemap request
   * @param download If true, download the sitemap
   * @returns Promise that resolves to the SSE subscription
   */
  async *monitorSitemapRequest(uuid: string, download: boolean = false) {
    yield* this.fetchStream<SitemapEvent>(`/api/v1/core/sitemaps/${uuid}/status/`, {
      params: { prefetched: download },
    });
  }

  /**
   * Delete/cancel a sitemap request
   * @param id UUID of the sitemap request
   * @returns Promise that resolves when the sitemap request is deleted
   */
  async stopSitemapRequest(id: string) {
    return this.delete(`/api/v1/core/sitemaps/${id}/`);
  }

  /**
   * Download a sitemap
   * @param id UUID of the sitemap request
   * @param outputFormat
   * @returns Promise that resolves to the sitemap
   */
  async getSitemapResults(
    id: string,
    outputFormat: SitemapOutputFormat = SitemapOutputFormat.Json,
  ): Promise<Array<string> | string | object> {
    if (outputFormat === SitemapOutputFormat.Json) {
      const request = await this.getSitemapRequest(id, true);
      return request.result as Array<string>;
    }

    if (outputFormat === SitemapOutputFormat.Markdown) {
      return this.get<string>(`/api/v1/core/sitemaps/${id}/markdown/`) as Promise<string>;
    }

    if (outputFormat === SitemapOutputFormat.Graph) {
      return this.get(`/api/v1/core/sitemaps/${id}/graph/`) as Promise<object>;
    }

    throw new Error('Invalid output format');
  }
}
